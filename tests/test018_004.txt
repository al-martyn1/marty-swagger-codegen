/* \file
   \brief Automatically generated file

 */


#include <string>
#include <exception>
#include <stdexcept>
#include <typeinfo>
#include <variant>
#include <optional>

#include "nlohmann/json.hpp"


/*
#define
struct ArrayText
{
    std::string value;

    ArrayText() : value() {}
    ArrayText( const ArrayText &a) : value(a.value) {}
    ArrayText& operator=( const ArrayText &a) { value = a.value; return *this; }
    ArrayText(const std::string &s) : value(s) {}
    operator std::string() const { return value; }
};

struct ObjectText
{
    std::string value;

    ObjectText() : value() {}
    ObjectText( const ObjectText &a) : value(a.value) {}
    ObjectText& operator=( const ObjectText &a) { value = a.value; return *this; }
    ObjectText(const std::string &s) : value(s) {}
    operator std::string() const { return value; }
};
*/


{% set enumNameStyle ='pascal' -%}
{% set enumValueStyle='camel'  -%}
{% set namespace = 'test/swagger::TinkoffOpenAPI'  -%}
{# -#}
{% set namespace = namespace|replace(old='::',new='/') -%}
{% set namespace = namespace|replace(old='\\',new='/') -%}
{% set namespaceList = namespace|split('/') -%}

// namespace (full): {{ namespace}}
{% for ns in namespaceList %}
namespace {{ns}} {
{%- endfor -%}


template < typename T >
using Opt = std::optional<T>;


namespace util{

// 1) 


} // namespace util



{# -#}
{# -#}
{# -#}
{% for ComponentTypeName in ComponentTypes %}{% set TypeSpec = components[ComponentTypeName] -%}
// TypeName: {{ ComponentTypeName }}
// {{ TypeSpec | tojson }}
{% if TypeSpec['enum'] %}
enum class {{ ComponentTypeName | ident(enumNameStyle) }}
{   invalid = 0
{% for enumItem in TypeSpec['enum'] -%}
  , {{ enumItem | ident(enumValueStyle) }} = {{ loop.index }}
{% endfor -%}
};
{% endif %}{# if TypeSpec['enum'] #}

{% endfor %}{# for ComponentTypeName in ComponentTypes #}


{% for ns in namespaceList | reverse %}
} // namespace {{ns}}{% endfor -%}

